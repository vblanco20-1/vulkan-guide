---
layout: default
title: Vulkan Initialization
parent:  "1. Initializing Vulkan"
nav_order: 1
---


## Vulkan 초기화
OpenGL과는 달리, Vulkan은 그래픽 명령을 즉시 실행하는 대신 매우 긴 초기화 단계를 거칩니다. 이 초기화 과정을 단축하기 위해 `VkBootstrap` 라이브러리를 사용할 것입니다. 이 라이브러리는 많은 양의 작업을 간소화해줍니다.

Vulkan은 매우 "직접적인" 제어를 제공하는 매우 명시적인 API입니다. 확장을 불러오거나, 사용할 GPU(들)을 선택하거나, Vulkan 명령에 사용할 초기 `VkInstance`와 `VkDevice` 구조체를 생성해야 합니다.

Vulkan은 OpenGL과는 달리 전역 상태(global state)가 없습니다. 따라서 모든 API 호출에서 `VkDevice`와 `VkInstance`를 직접 전달해야합니다. 이 가이드에서는 `vulkan-1.dll`을 직접 링크하지만 이는 유일한 방법이 아닙니다. 함수 포인터를 "수동으로" 불러올 수도 있습니다. `vulkan-1.dll`을 링킹하는 것은 확장 함수도 불러오는 것은 아니므로, 별도로 불러와야 합니다. 프로젝트 코드에서는 이러한 확장 함수를 불러올 수 있도록 `Volk` 라이브러리가 제공합니다. 주요 튜토리얼 챕터에서는 이를 사용하지 않을 것이지만 이후 활용할 가능성이 높기 때문에 포함되어 있습니다.

## VkInstance
모든 것의 핵심인 `VkInstance`입니다. 이는 Vulkan API 문맥(Context)을 나타냅니다. `VkInstance`를 생성할 때, 원한다면 검증 레이어를 활성화 할 수 있으며, VK_KHR_surface와 같은 필요한 확장도 설정할 수 있습니다. 또한, Vulkan 드라이버에서 오류가 발생하거나 로그를 남겨야 할 때 사용할 로거를 연결할 수도 있습니다. `VkInstance`를 생성할 때 가장 중요한 것은 검증 레이어와 확장을 활성화하는 것입니다.

일반적으로 애플리케이션은 전체 실행 동안 단 하나의 `VkInstance`만 생성하면 됩니다. 이는 애플리케이션의 전역 Vulkan 문맥 역할을 하기 때문입니다.

## VkPhysicalDevice
`VkInstance`를 생성한 후, 시스템에서 사용가능한 GPU를 조회할 수 있습니다.

Vulkan에서는 시스템에 존재하는 GPU와 해당 GPU 기능 목록을 가져올 수 있습니다. 이 모든 정보들은 GPU를 나타내는 `VkPhysicalDevice`를 통해 나타납니다. 예를 들어, 게이밍 전용 GPU가 장착된 게이밍 전용 PC의 경우 단 하나의 `VkPhysicalDevice`만을 존재할 가능성이 높습니다. 이 경우 여러 GPU들 중 고를 필요 없이 하나만 선택하면 됩니다.

더 흥미로운 상황은 랩탑에서 발생합니다. 랩탑은 보통 2개의 GPU를 갖는 경우가 있습니다. 하나는 저전력의 CPU 내장 GPU이고, 다른 하나는 고성능의 전용 GPU입니다. 이 경우 애플리케이션은 렌더링에 사용할 GPU를 선택해야 하며, 최적의 방법은 사용자가 직접 선택할 수 있도록 하는 것입니다. 사용자는 배터리 수명을 유지하기 위해 저전력 GPU를 사용하고 싶을 수 있습니다.

GPU를 선택하는 것 외에도, `VkPhysicalDevice`를 통해 GPU의 기능, 메모리 크기, 그리고 지원하는 확장을 조회할 수 있습니다. 이는 사용 가능한 VRAM의 크기와 GPU가 고급 기능을 지원하는 지를 정확히 알아야 하는 고급 애플리케이션에서 매우 중요합니다.

## VkDevice
`VkDevice`를 생성할 수 있습니다. `VkDevice`는 GPU 하드웨어의 실제 드라이버이며, GPU에게 소통하는 수단입니다. 디버깅 기능과 초기화를 제외한 대부분의 Vulkan 명령은 `VkDevice`를 필요로 합니다. 장치(device)를 생성할 때는 활성화할 확장 목록을 지정해야 합니다. 필요하지 않은 확장은 활성화하지 않는 것이 좋습니다. 불필요한 기능을 확인하는 과정에서 드라이버가 성능이 저하될 수 있기 때문입니다.

엔진이 여러 `VkDevice`를 동시에 다룰 수도 있으며, 이를 통해 하나의 프로그램에서 여러 GPU를 사용할 수 있습니다. 이 튜토리얼에서는 다루지 않지만, 여러 GPU간 컴퓨트 셰이더를 작동할 때 알아두면 유용한 내용입니다.

## 교환 사슬(Swapchain)
GPU가 올바르게 초기화했지만, 화면에 실제로 렌더링을 수행해야 합니다. 이를 위해 교환사슬(swapchain)을 사용합니다. 교환사슬은 OS 또는 창 시스템이 제공하는 구조로, 이미지를 그린 후 화면에 표시할 수 있도록 합니다. 교환사슬은 Vulkan의 핵심 사양은 아닙니다. 선택적 기능이며 플랫폼마다 차이가 있을 수 있습니다. 만약 Vulkan을 컴퓨트 셰이더 계산 혹은 오프라인 렌더링에 사용한다면, 교환사슬을 설정할 필요는 없습니다.

교환사슬은 주어진 크기로 생성되며, 창 크기가 변경된다면 교환사슬을 다시 만들어야 합니다.

교환사슬 이미지의 포맷은 플랫폼과 GPU에 따라 달라질 수 있습니다. 따라서 교환사슬에서 요구하는 포맷의 이미지를 저장해야 합니다. 다른 포맷의 이미지를 렌더링하면 그래픽 이상이나 크래시가 일어날 수 있기 때문입니다.

교환사슬은 화면에 표시하기 위해 운영체제에서 접근할 수 있는 이미지와 이미지뷰(image-view)의 목록을 포함합니다. 교환사슬을 더 적거나 더 많은 이미지로 생성할 수도 있지만, 일반적으로 더블 버퍼링 혹은 트리플 버퍼링을 수행하기 위해 2,3개의 이미지만을 사용합니다.

교환사슬을 만들 때 가장 중요한 것은 표시 모드(Present Mode)를 선택하는 것입니다. 이는 교환사슬이 화면 표시와 어떻게 동기화할지를 제어합니다.

모든 표시 모드의 자세한 설명은 아래 Vulkan 사양 페이지에서 확인할 수 있습니다. [Vulkan Spec: VkPresentModeKHR](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap34.html#VkPresentModeKHR)


- `VK_PRESENT_MODE_IMMEDIATE_KHR` 교환사슬을 아무것도 기다리지 않고 이미지를 받는 즉시 표시하도록 합니다. 이는 화면 찢어짐(tearing)이 발생할 수 있으며 일반적으로 권장되지 않습니다.
- `VK_PRESENT_MODE_FIFO_KHR` 새로고침 주기에 따라 표시할 이미지 큐(queue)를 사용합니다. 큐가 가득 차면 이미지가 표시되어 빈 공간이 생길 때 까지 애플리케이션이 대기합니다. 이는 "강한 VSync" 표시 모드이며, 애플리케이션의 FPS가 화면의 주사율에 고정됩니다.
- `VK_PRESENT_MODE_FIFO_RELAXED_KHR` . Fifo VSync과 거의 같지만 VSync VSync가 유연하게 작동합니다. 만약 애플리케이션의 FPS가 화면의 최적 FPS보다 낮다면, 이미지를 즉시 표시하여 찢어짐 현상이 발생할 수 있습니다. 예를 들어, 화면이 60Hz를 지원하는데 렌더링이 55Hz로 이루어진다면, 일반적인 Fifo에서는 다음 VSync주기 까지 대기해야 하므로 30FPS까지 떨어질 수 있지만, 이 모드는 그대로 55FPS로 표시합니다. 다만 이 과정에서 화면 찢어짐이 발생할 수 있습니다. 
- `VK_PRESENT_MODE_MAILBOX_KHR` . 이 모드는 이미지 목록을 유지하며, 한 이미지가 화면에 표시되는 동안 나머지 이미지에 계속해서 렌더링할 수 있습니다. 이미지를 표시할 시점이 되면 가장 최근에 렌더링 된 이미지를 선택합니다. 엄격한 VSync 없이 트리플 버퍼링을 사용하고 싶을 때 적합한 방식입니다.

`VK_PRESENT_MODE_IMMEDIATE_KHR`은 찢어짐 현상 거의 사용되지 않습니다. 극도로 낮은 지연이 필요한 경우, 찢어짐 현상을 감수하고 사용할 수도 있습니다.

일반적인 애플리케이션은 MAILBOX 혹은 FIFO중 하나를 사용합니다. 이는 엄격한 VSync를 원하는 지, 혹은 트리플 버퍼링을 선호하는 지에 따라 달라집니다.

이 가이드에서는 FIFO_RELAXED 모드를 사용하겠습니다. 렌더링 속도의 상한을 설정해주며, 많은 객체를 렌더링하지 않으므로 프레임 속도가 5000FPS까지 올라가 과열 등의 문제가 발생하는 것을 방지하는 데 적합합니다. 하지만 실제 애플리케이션에서 작업 부하가 있다면 MAILBOX가 더 적절할 수 있습니다.

다음 글: [ Vulkan 초기화 코드]({{ site.baseurl }}{% link docs/new_chapter_1/vulkan_init_code.md %})  

{% include comments.html term="Vkguide 2 Beta Comments" %}

