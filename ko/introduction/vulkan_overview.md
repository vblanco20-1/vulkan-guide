---
layout: default
lang: ko
title: Vulkan API
nav_order: 1
parent: 소개
---

![VulkanLogo](/assets/images/Vulkan_170px_Dec16.jpg)

## Vulkan 소개

Vulkan은 크로노스 그룹이 개발한 크로스 플랫폼 그래픽스 API(Application Program Interface)입니다. Vulkan API는 표준 규격이므로 다양한 디바이스, 플랫폼, 그리고 여러 프로그래밍 언어로 구현될 수 있습니다.

Vulkan은 고성능 멀티쓰레딩 애플리케이션에 사용되도록 설계되었습니다.특히 Vulkan은 명시적인 설계 방식을 채택하여 그래픽 드라이버의 작업을 줄이는 이점을 갖습니다. Vulkan을 올바르게 사용하는 것은 고성능, 저지연, 그리고 일관된 프레임을 얻을 수 있습니다.

## Vulkan API 개요

Vulkan API는 함수 목록, 전달할 인자, 그리고 반환 타입을 제공합니다. 이는 C 언어로 작성되었으며, 대부분의 언어와 호환 될 수 있습니다.

이 튜토리얼은 C++로 작성되었지만 Rust 혹은 순수 C와 같은 저수준 언어로 포팅하는 것은 간단할 것입니다.

## Vulkan이 필요한 상황

만약 주요 병목이 GPU에서 일어난다면, Vulkan을 구현하는 것만으로는 성능이 충분히 향상되지 않아 그만한 가치가 없을 수 있습니다. Vulkan이 OpenGL과 비교하여 상당히 어렵고 종종 개발하는 데 더 오랜 시간이 걸립니다.

만약 애플리케이션이 커다란 맵, 동적 월드, 혹은 많은 양의 오브젝트를 담는 CAD 씬을 포함한다면, Vulkan의 멀티쓰레딩을 통해 성능 향상을 기대할 수 있습니다.

모바일 환경에서는 파편화 문제가 있을 수 있습니다. 모든 스마트폰이 Vulkan을 지원하는 것은 아니며(특히 구형 기기), 지원하더라도 드라이버 품질에 문제가 있을 수 있습니다. 특히 Vulkan을 지원하는 드라이버가 탑재된 폰은 더 적은 배터리로 더 적은 CPU 오버헤드와 높은 성능을 기대할 수 있습니다.

## 크로스 플랫폼

모바일과 데스크탑을 모두 지원하는 API라는 점에서 Vulkan의 설계는 다른 그래픽스 API와 비교해 특수한 면이 있습니다. Vulkan의 많은 기능이 선택적이며 사용하려면 명시적으로 활성화해야 합니다. 대부분의 데스크탑 GPU에서는 지원하지만 모바일에서는 지원하지 않는 기능이 있는 것도 흔한 일입니다.

Vulkan을 모바일과 데스크탑에서 실행할 때, 하나 또는 두 개의 핵심 렌더링 경로를 사용할 수 있습니다. 일반적으로 2개의 렌더링 경로를 사용하는 것이 권장되며, 그렇지 않으면 최적의 성능을 얻기 어려울 수 있습니다. API가 통합되어 있기 때문에 두 렌더링 경로 간 코드를 공유할 수 있다는 것을 의미합니다.

이 튜토리얼에서는 데스크탑을 위한 Vulkan을 작성하는 것에 집중할 것이지만, 두 GPU의 차이에 대해서도 다룰 것입니다.

## 검증 레이어

Vulkan API는 방대하고 실수하기 쉽지만, 검증 레이어로 이를 해결할 수 있습니다.

검증 레이어는 API의 올바르지 않은 사용을 감지하고 기록하는 선택적 기능입니다.

검증 레이어는 함수 호출을 가로채 데이터를 검증하는 방식으로 작동합니다. 만약 모든 데이터가 올바르게 검증되었다면 드라이버에 대한 호출이 정상적으로 수행될 것입니다. 이 과정에서 함수 가로채기와 검증 실행이 성능 하락을 일으킬 수 있다는 점을 유의해야합니다.

검증 레이어는 올바르지 않은 구현이나 올바르지 않은 열거형 사용, 동기화 문제, 객체 생성주기와 같은 에러를 잡는 데 유용합니다. 작성한 코드가 요구사항을 준수했는지를 보장하기 위해 개발 도중 검증 레이어를 활성화 하는 것을 추천합니다. 애플리케이션을 실행했을 때 검증 레이어의 오류가 없는 것은 좋은 신호이지만, 이것만으로 다른 하드웨어에서 잘 실행될 것이라고 판단할 수 없습니다. 애플리케이션을 가능한 많은 디바이스에서 실행해보는 것을 권장합니다.

중요한 점은 검증 레이어가 초기화되지 않은 메모리와 올바르지 않은 포인터와 같은 버그를 잡아주지는 않는다는 점입니다. 이러한 버그를 잡기 위해서는 Address Sanitizer와 Vanlgrind를 사용하는 편을 추천합니다. 이러한 도구를 사용할 때 그래픽 드라이버는 종종 잘못된 탐지로 출력에 잡음이 생길 수 있습니다.

## 사용법과 일반적인 접근 방식

Vulkan API에서는 대부분의 요소가 직접 생성하고 사용하도록 설계되어있습니다. 이는 이미지, 텍스쳐, 버퍼(정점 데이터와 같은 메모리) 같은 실제 GPU 자원 뿐만 아니라 매우 많은 양의 내부 설정 구조체도 포함합니다.

예를 들어, 래스터라이저(rasterizer)와 같은 GPU 고정 함수는 파이프라인 객체에 저장되며, 이 객체는 셰이더와 다른 설정들을 포함합니다. OpenGL과 DX11에서는 이를 렌더링 중 즉석에서 계산합니다. Vulkan에서 이를 사용할 때에는 객체들을 캐싱할 지, 혹은 렌더링 중 즉석에서 만들 지를 생각해야 합니다. 파이프라인과 같은 몇몇 객체들은 생성하는 비용이 비싼 편입니다. 따라서 이를 화면 로딩 시 혹은 백그라운드 쓰레드에서 생성하는 것이 최적입니다. 디스크립터 셋(DescriptorSet)과 같은 다른 객체들은 비용이 낮아 렌더링 중 필요할 때 생성해도 무방합니다.

Vulkan의 모든 것들은 기본적으로 사전빌드되므로, GPU의 대부분의 상태 검사는 객체를 생성할 때 이루어집니다. 따라서 렌더링 자체의 작업량이 줄어들어 성능이 향상됩니다. 이러한 객체들이 어떻게 만들어지고 사용되는지 잘 이해하면 전체 실행 흐름을 효과적으로 제어하여 프레임을 부드럽게 만들 수 있습니다.

실제 GPU 명령을 실행할 때, GPU의 모든 작업은 커맨드 버퍼(CommandBuffer)에 기록되어 큐(Queue)로 제출됩니다. 먼저 커맨드 버퍼를 할당하고, 이를 작성해 큐에 제출하는 것으로 실행할 수 있습니다. 커맨드 버퍼를 큐에 제출하면 GPU에서 해당 명령의 실행이 시작됩니다. 언제 실행이 끝날지를 제어하는 도구도 있습니다. 만약 여러 커맨드 버퍼를 서로 다른 큐에 제출한다면, 병렬로 실행하는 것도 가능합니다.

Vulkan에는 프레임이라는 개념이 없습니다. 이는 렌더링 방식이 전적으로 개발자에게 맡겨졌다는 의미죠. 중요한 것은 언제 프레임을 화면에 표시할 것인지 이며, 이는 스왑체인(swapchain)을 통해 이루어집니다. 하지만 렌더링한 이미지를 네트워크를 통해 전송하거나, 파일로 이미지를 저장하거나, 스왑체인을 통해 스크린에 이를 표시하는 것에는 근본적인 차이는 없습니다.

이는 Vulkan이 완전히 헤드리스(headless)모드로 사용할 수 있다는 것을 의미합니다. 즉, 화면에 아무것도 표시하지 않고 이미지를 렌더링한 후 이미지를 디스크에 저장할 수 있습니다(테스트 하기에 매우 유용하죠!). 혹은 Vulkan을 레이트레이싱과 같은 GPU 연산이나 다른 컴퓨팅 작업을 수행하는 도구로도 사용할 수 있습니다.

다음 글: [Vulkan 렌더링 흐름]({{ site.baseurl }}{% link docs/introduction/vulkan_execution.md %})


{% include comments.html term="Introduction Comments" %}